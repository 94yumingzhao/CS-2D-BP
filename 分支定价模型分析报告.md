# 二维下料分支定价模型分析报告

## 一、问题描述

这是一个**两阶段二维下料问题 (Two-Stage 2D Cutting Stock Problem)**:

- **第一阶段**: 沿宽度方向将母板切割成条带 (strips)
- **第二阶段**: 沿长度方向将条带切割成子件 (items)

### 切割示意图

```
母板 (Stock)
+--------------------------------------------------+
|  条带1 (宽度=w1)                                  |
|  +------+ +------+ +------+                      |
|  |子件1 | |子件2 | |子件3 |        (沿长度切割)   |
|  +------+ +------+ +------+                      |
+--------------------------------------------------+
|  条带2 (宽度=w2)                                  |
|  +----------+ +----------+                       |
|  |  子件4   | |  子件5   |                       |
|  +----------+ +----------+                       |
+--------------------------------------------------+
|  条带3 (宽度=w3)                                  |
|  ...                                             |
+--------------------------------------------------+
        ^
        |
    沿宽度方向切割
```

---

## 二、当前主问题模型

### 数学表述

```
min  sum(y_k)                              // 最小化母板使用数量
s.t. sum(C_jk * y_k) - sum(x_p) >= 0       // 条带平衡约束 (j=1..J)
     sum(B_ip * x_p) >= d_i                // 子件需求约束 (i=1..I)
     y_k >= 0, x_p >= 0
```

### 符号说明

| 符号 | 含义 |
|------|------|
| `y_k` | 母板模式 k 的使用次数 |
| `x_p` | 条带模式 p 的使用次数 |
| `C_jk` | 母板模式 k 产出条带类型 j 的数量 |
| `B_ip` | 条带模式 p 产出子件类型 i 的数量 |
| `d_i` | 子件类型 i 的需求量 |
| `J` | 条带类型数量 |
| `I` | 子件类型数量 |

### 约束矩阵结构

```
        Y列 (母板模式)      X列 (条带模式)
       [  y_1 ... y_K  |  x_1 ... x_P  ]
       +---------------+---------------+
条带1  |  C_11 ... C_1K | -1  0  0 ... |  >= 0
条带2  |  C_21 ... C_2K |  0 -1  0 ... |  >= 0
  :    |      :        |      :       |
条带J  |  C_J1 ... C_JK |  0  0 ... -1 |  >= 0
       +---------------+---------------+
子件1  |   0  ...  0   | B_11 ... B_1P |  >= d_1
子件2  |   0  ...  0   | B_21 ... B_2P |  >= d_2
  :    |      :        |      :       |
子件I  |   0  ...  0   | B_I1 ... B_IP |  >= d_I
       +---------------+---------------+
目标   |   1  ...  1   |  0  ...  0   |  min
```

---

## 三、子问题结构

### SP1: 第一阶段子问题 (宽度背包)

决定母板上放置哪些条带类型。

```
max  sum(v_j * G_j)
s.t. sum(w_j * G_j) <= W
     G_j >= 0, integer
```

- `v_j`: 条带约束 j 的对偶价格
- `w_j`: 条带类型 j 的宽度
- `W`: 母板宽度
- `G_j`: 条带类型 j 的放置数量

**定价判断**: `reduced_cost = 1 - SP1_obj`，若 `SP1_obj > 1` 则添加新 Y 列

### SP2: 第二阶段子问题 (长度背包)

决定条带上放置哪些子件类型。

```
max  sum(w_i * D_i)
s.t. sum(l_i * D_i) <= L
     D_i >= 0, integer
     (仅考虑 width_i <= strip_width 的子件)
```

- `w_i`: 子件约束 i 的对偶价格
- `l_i`: 子件类型 i 的长度
- `L`: 母板长度 (= 条带长度)
- `D_i`: 子件类型 i 的放置数量

**定价判断**: `reduced_cost = v_k - SP2_obj`，若 `SP2_obj > v_k` 则添加新 X 列

---

## 四、发现的问题

### 问题1: SP2 几何约束错误 [严重]

**位置**: `sub_problem.cpp:214`

```cpp
// 条件1: 子件宽度必须 <= 条带宽度
if (data.item_types_[i].width_ <= strip_wid) {
```

**问题描述**:

当前代码允许宽度小于条带宽度的子件放入条带，这意味着**不同宽度的子件可以放在同一条带中**。

**数学错误**:

在两阶段切割中，条带是沿宽度方向切割的水平槽。同一条带内的所有子件必须具有**相同的宽度**（等于条带宽度）。当前模型允许 `width_i < strip_width`，会产生无法实现的几何切割方案。

**示例**:

```
错误的切割方案 (当前代码可能生成):
+--------------------------------------------------+
|  条带 (宽度=180)                                  |
|  +------+  +----------+                          |
|  |w=120 |  |  w=180   |    <-- 不同宽度的子件!    |
|  +------+  +----------+                          |
|  ^^^^^^^^                                        |
|  这部分空间无法利用，几何上不可行                  |
+--------------------------------------------------+

正确的切割方案:
+--------------------------------------------------+
|  条带 (宽度=180)                                  |
|  +----------+  +----------+  +----------+        |
|  |  w=180   |  |  w=180   |  |  w=180   |        |
|  +----------+  +----------+  +----------+        |
+--------------------------------------------------+
```

**正确做法**:

SP2 应该只考虑 `width_i == strip_width` 的子件类型:

```cpp
if (data.item_types_[i].width_ == strip_wid) {
```

---

### 问题2: 分支变量值存储错误 [严重]

**位置**: `branching.cpp:31`

```cpp
double var_val = node.branch_var_val_;
node.branched_vals_.push_back(var_val);  // 存储的是分数值!
```

**问题描述**:

`branched_vals_` 应该存储分支后的整数边界值 (`branch_floor_` 或 `branch_ceil_`)，而不是原始分数值。

**后果**:

在 `new_node_first_master_problem.cpp:104` 中使用这些值作为变量边界:

```cpp
IloNum var_lb = parent_node.branched_vals_[index];  // 用分数值作为边界!
IloNum var_ub = parent_node.branched_vals_[index];
```

这导致变量被固定为分数值，完全破坏了分支定界的正确性。

**示例**:

```
假设变量 y_1 的 LP 解为 2.7

正确的分支:
  左子节点: y_1 <= 2 (floor)
  右子节点: y_1 >= 3 (ceil)

当前代码的分支:
  子节点: y_1 = 2.7 (固定为分数值，错误!)
```

**正确做法**:

应该存储取整后的边界值，而不是原始分数值。

---

### 问题3: 整数性判断精度问题 [中等]

**位置**: `branching.cpp:96-98`

```cpp
int int_val = int(sol_val);
if (int_val != sol_val) {
```

**问题描述**:

浮点数比较不应该使用 `==`。由于数值精度问题:
- `sol_val = 1.9999999999` 会被错误判断为非整数
- `sol_val = 2.0000000001` 会被错误判断为非整数

**正确做法**:

```cpp
double rounded = round(sol_val);
if (fabs(sol_val - rounded) > kZeroTolerance) {
    // 非整数
}
```

---

### 问题4: 条带类型与子件类型对应关系 [低]

**位置**: `input.cpp:60`

```cpp
params.num_strip_types_ = params.num_item_types_;
```

**问题描述**:

假设条带类型数 = 子件类型数，即每种子件对应一种条带类型。

**限制**:

这意味着如果有两种子件具有相同宽度，它们会被视为不同的条带类型，导致模型冗余。

**示例**:

```
子件类型1: 长度=100, 宽度=50
子件类型2: 长度=80,  宽度=50  <-- 相同宽度
子件类型3: 长度=120, 宽度=70

当前代码: 3种条带类型 (冗余)
标准做法: 2种条带类型 (按唯一宽度: 50, 70)
```

**影响**: 模型冗余，求解效率降低，但不影响正确性。

---

### 问题5: X 列与条带类型的对应关系

**位置**: `sub_problem.cpp:135-137`

```cpp
for (int j = 0; j < num_strip_types; j++) {
    temp_col.push_back((k == j) ? -1 : 0);
}
```

**问题描述**:

由于问题1，条带类型 k 的 X 列可能包含宽度小于条带 k 宽度的子件，但这些子件在几何上无法从条带 k 中切出。

**依赖**: 此问题在修复问题1后自动解决。

---

## 五、定价公式验证

| 变量类型 | Reduced Cost 公式 | 判断条件 | 代码实现 | 状态 |
|----------|-------------------|----------|----------|------|
| Y 列 | `1 - sum(v_j * C_j)` | `SP1_obj > 1` | `sp1_obj_val > 1 + kRcTolerance` | 正确 |
| X 列 | `v_k - sum(w_i * B_i)` | `SP2_obj > v_k` | `sp2_obj_ > dual_val + kRcTolerance` | 正确 |

**结论**: 定价逻辑本身是正确的。

---

## 六、修复建议

### 优先级排序

| 优先级 | 问题 | 影响程度 | 修复难度 |
|--------|------|----------|----------|
| **P0** | SP2 几何约束错误 | 产生不可行的切割方案 | 低 |
| **P0** | 分支变量值存储错误 | 分支定界完全失效 | 低 |
| **P1** | 整数性判断精度 | 可能导致错误分支 | 低 |
| **P2** | 条带类型定义 | 模型冗余，效率降低 | 中 |

### 修复方案概述

#### 修复1: SP2 几何约束

```cpp
// sub_problem.cpp:214
// 修改前:
if (data.item_types_[i].width_ <= strip_wid) {

// 修改后:
if (data.item_types_[i].width_ == strip_wid) {
```

#### 修复2: 分支变量值存储

需要修改 `branching.cpp` 和 `new_node_first_master_problem.cpp` 中的相关逻辑，确保:
- `branched_vals_` 存储的是取整后的边界值
- 左子节点使用 `floor` 值
- 右子节点使用 `ceil` 值

#### 修复3: 整数性判断

```cpp
// branching.cpp:96-98
// 修改前:
int int_val = int(sol_val);
if (int_val != sol_val) {

// 修改后:
double rounded = round(sol_val);
if (fabs(sol_val - rounded) > kZeroTolerance) {
```

---

## 七、附录: 代码文件清单

| 文件 | 功能 |
|------|------|
| `2DBP.h` | 主头文件，数据结构定义 |
| `main.cpp` | 程序入口 |
| `input.cpp` | 数据读取 |
| `primal_heuristic.cpp` | 启发式生成初始解 |
| `root_node_column_generation.cpp` | 根节点列生成 |
| `root_node_first_master_problem.cpp` | 根节点主问题 |
| `sub_problem.cpp` | SP1/SP2 子问题求解 |
| `update_master_problem.cpp` | 主问题更新 |
| `branching.cpp` | 分支变量选择 |
| `branch_and_price.cpp` | 分支定价主循环 |
| `new_node_generating.cpp` | 新节点生成 |
| `new_node_first_master_problem.cpp` | 新节点主问题 |
| `new_node_column_generation.cpp` | 新节点列生成 |
| `output_results.cpp` | 结果输出 |
| `output_models.cpp` | 模型输出 |

---

**报告生成时间**: 2025-12-27
